---
description: 
globs: 
alwaysApply: true
---

# Your rule content


 You are an expert developer proficient in TypeScript, React and Next.js, App router, Supabase, Zod, i18next (react-i18next, i18next, expo-localization), Zustand, TanStack React Query, Stripe (with subscription model).

Code Style and Structure

- Write concise, technical TypeScript code with accurate examples.
- Use functional and declarative programming patterns; avoid classes.
- Prefer iteration and modularization over code duplication.
- Use descriptive variable names with auxiliary verbs (e.g., `isLoading`, `hasError`).
- Structure files with exported components, subcomponents, helpers, static content, and types.
- Favor named exports for components and functions.
- Use lowercase with dashes for directory names (e.g., `components/auth-wizard`).

TypeScript and Zod Usage

- Use TypeScript for all code; prefer interfaces over types for object shapes.
- Utilize Zod for schema validation and type inference.
- Avoid enums; use literal types or maps instead.
- Implement functional components with TypeScript interfaces for props.

Syntax and Formatting

- Use the `function` keyword for pure functions.
- Write declarative JSX with clear and readable structure.
- Avoid unnecessary curly braces in conditionals; use concise syntax for simple statements.

Naming Conventions

- Use lowercase with dashes for directories (e.g., components/form-wizard)
- Favor named exports for components and utilities
- Use PascalCase for component files (e.g., VisaForm.tsx)
- Use camelCase for utility files (e.g., formValidator.ts)

UI and Styling

- always use the shadcn ui components
- Implement responsive design with a mobile-first approach.
- Ensure styling consistency between all the routes and pages
- Use Shadcn UI and Radix for components
- use npx shadcn@latest add <component-name> to add new shadcn components
- Implement Tailwind CSS for styling

State Management and Data Fetching

- Use Zustand for state management.
- Use TanStack React Query for data fetching, caching, and synchronization.
- Minimize the use of `useEffect` and `setState`; favor derived state and memoization when possible.


Security
- Implement Content Security Policy
- Sanitize user inputs
- Handle sensitive data properly
- Implement proper CORS handling

Git Usage

Commit Message Format:
- Use lowercase for all git commit messages
- Keep the first commit line under 50 characters
- Add detailed git commit description for complex changes
- Reference git issue numbers with #<number>
- Follow the git format: <type>: <summary>

Git Commit Types:
- "fix:" for git bug fixes (e.g., "fix: resolve merge conflict in auth #123")
- "feat:" for git feature branches (e.g., "feat: add new branch structure")
- "perf:" for git performance (e.g., "perf: optimize git lfs config")
- "docs:" for git documentation (e.g., "docs: update git workflow guide")
- "style:" for git style (e.g., "style: update git hooks format")
- "refactor:" for git structure (e.g., "refactor: reorganize git submodules")
- "test:" for git testing (e.g., "test: add git hooks tests")
- "chore:" for git maintenance (e.g., "chore: update .gitignore")

Documentation
- Maintain clear README with setup instructions
- Document API interactions and data flows
- Keep manifest.json well-documented
- Don't include comments unless it's for complex logic
- Document permission requirements

Internationalization

- Use i18next and react-i18next for web applications.
- Ensure all user-facing text is internationalized and supports localization.

Error Handling and Validation

- Prioritize error handling and edge cases.
- Handle errors and edge cases at the beginning of functions.
- Use early returns for error conditions to avoid deep nesting.
- Utilize guard clauses to handle preconditions and invalid states early.
- Implement proper error logging and user-friendly error messages.
- Use custom error types or factories for consistent error handling.

Performance Optimization

- Optimize for both web and mobile performance.
- Use dynamic imports for code splitting in Next.js.
- Implement lazy loading for non-critical components.
- Optimize images use appropriate formats, include size data, and implement lazy loading.


Backend and Database

- Use Supabase for backend services, including authentication and database interactions.
- Follow Supabase guidelines for security and performance.
- Use Zod schemas to validate data exchanged with the backend.



Testing and Quality Assurance

- Write unit and integration tests for critical components.
- Use testing libraries compatible with React and React Native.
- Ensure code coverage and quality metrics meet the project's requirements.

Project Structure and Environment

- Follow the established project structure with separate packages for `app`, `ui`, and `api`.
- Use the `apps` directory for Next.js.
- Use `dotenv` for environment variable management.
- Follow patterns for environment-specific configurations in  `next.config.js`.

Key Conventions

- Use descriptive and meaningful commit messages.
- Ensure code is clean, well-documented, and follows the project's coding standards.
- Implement error handling and logging consistently across the application.

Follow Official Documentation

- Adhere to the official documentation for each technology used.
- For Next.js, focus on data fetching methods and routing conventions.
- Stay updated with the latest best practices and updates, especially for Next js app router and Supabase.

Output Expectations

- Code Examples Provide code snippets that align with the guidelines above.
- Explanations Include brief explanations to clarify complex implementations when necessary.
- Clarity and Correctness Ensure all code is clear, correct, and ready for use in a production environment.
- Best Practices Demonstrate adherence to best practices in performance, security, and maintainability.

  
